# -*- coding: utf-8 -*-
"""DESAFIO_CRUD

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LmGswRZjpK9O6l_gka-FxfgMxlkHwmzS
"""

!pip install fastapi uvicorn nest_asyncio

from fastapi import FastAPI, HTTPException, Depends, status, Header
from pydantic import BaseModel
from typing import List, Optional
import sqlite3
import jwt
import datetime
from passlib.context import CryptContext

# Configurações do FastAPI
app = FastAPI()

# Configurações de segurança (JWT e criptografia)
SECRET_KEY = "NATALIA"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# Banco de dados SQLite
def get_db():
    conn = sqlite3.connect("funcionarios.db")
    cursor = conn.cursor()
    return conn, cursor

# Modelo de Funcionário
class Funcionario(BaseModel):
    nome: str
    sobrenome: str
    usuario: str
    departamento: str
    email: str

class Usuario(BaseModel):
    email: str
    senha: str
    perfil: str  # super ou gestor

# Função para criar o banco de dados e as tabelas necessárias
def criar_tabelas():
    conn, cursor = get_db()

    # Criando a tabela de usuários
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS usuarios (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        email TEXT UNIQUE,
        senha TEXT,
        perfil TEXT
    )
    """)

    # Criando a tabela de funcionários
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS funcionarios (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        nome TEXT,
        sobrenome TEXT,
        usuario TEXT UNIQUE,
        departamento TEXT,
        email TEXT
    )
    """)

    # Inserindo um usuário de exemplo (com senha criptografada)
    hashed_password = pwd_context.hash("NATALIA")
    cursor.execute("""
    INSERT INTO usuarios (email, senha, perfil) VALUES ('natalia@exemplo.com', ?, 'super');
    """, (hashed_password,))

    # Commit e fechamento da conexão
    conn.commit()
    conn.close()

# Função para criar o JWT
def criar_jwt_token(data: dict):
    expiration = datetime.datetime.utcnow() + datetime.timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode = data.copy()
    to_encode.update({"exp": expiration})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

# Função para verificar o JWT
def verificar_token(token: str):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except jwt.PyJWTError:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Token inválido ou expirado")

# Criar tabelas
criar_tabelas()

# Endpoint de Login (para obter o JWT)
@app.post("/login")
def login(usuario: Usuario):
    conn, cursor = get_db()
    cursor.execute("SELECT * FROM usuarios WHERE email = ?", (usuario.email,))
    user = cursor.fetchone()

    if user and pwd_context.verify(usuario.senha, user[2]):
        token_data = {"sub": usuario.email, "perfil": user[3]}
        token = criar_jwt_token(token_data)
        return {"access_token": token, "token_type": "bearer"}
    else:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Credenciais inválidas")

# Criar Perfil de Funcionário
@app.post("/funcionarios")
def criar_funcionario(funcionario: Funcionario, token: str = Header(...)):
    payload = verificar_token(token)
    if payload["perfil"] not in ["super", "gestor"]:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Permissão insuficiente")

    conn, cursor = get_db()
    cursor.execute("INSERT INTO funcionarios (nome, sobrenome, usuario, departamento, email) VALUES (?, ?, ?, ?, ?)",
                   (funcionario.nome, funcionario.sobrenome, funcionario.usuario, funcionario.departamento, funcionario.email))
    conn.commit()
    conn.close()
    return {"message": "Funcionário criado com sucesso!"}

# Visualizar Perfis de Funcionários
@app.get("/funcionarios")
def visualizar_funcionarios(token: str = Header(...), departamento: Optional[str] = None):
    payload = verificar_token(token)

    conn, cursor = get_db()

    if payload["perfil"] == "super":
        query = "SELECT * FROM funcionarios"
        params = ()
    elif payload["perfil"] == "gestor":
        if departamento:
            query = "SELECT * FROM funcionarios WHERE departamento = ?"
            params = (departamento,)
        else:
            query = "SELECT * FROM funcionarios WHERE departamento = ?"
            params = (payload["perfil"],)  # Usando o departamento do gestor
    else:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Permissão insuficiente")

    cursor.execute(query, params)
    funcionarios = cursor.fetchall()
    conn.close()

    return {"funcionarios": funcionarios}

# Atualizar Perfil de Funcionário
@app.put("/funcionarios/{funcionario_id}")
def atualizar_funcionario(funcionario_id: int, funcionario: Funcionario, token: str = Header(...)):
    payload = verificar_token(token)
    conn, cursor = get_db()

    # Verificar se o perfil tem permissão para atualizar
    cursor.execute("SELECT departamento FROM funcionarios WHERE id = ?", (funcionario_id,))
    funcionario_atual = cursor.fetchone()
    if not funcionario_atual:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Funcionário não encontrado")

    if payload["perfil"] == "super":
        cursor.execute("""
            UPDATE funcionarios SET nome = ?, sobrenome = ?, usuario = ?, departamento = ?, email = ?
            WHERE id = ?
        """, (funcionario.nome, funcionario.sobrenome, funcionario.usuario, funcionario.departamento, funcionario.email, funcionario_id))
    elif payload["perfil"] == "gestor" and funcionario_atual[0] == payload["perfil"]:
        cursor.execute("""
            UPDATE funcionarios SET nome = ?, sobrenome = ?, usuario = ?, departamento = ?, email = ?
            WHERE id = ?
        """, (funcionario.nome, funcionario.sobrenome, funcionario.usuario, funcionario.departamento, funcionario.email, funcionario_id))
    else:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Permissão insuficiente")

    conn.commit()
    conn.close()
    return {"message": "Perfil atualizado com sucesso"}

# Deletar Perfil de Funcionário
@app.delete("/funcionarios/{funcionario_id}")
def deletar_funcionario(funcionario_id: int, token: str = Header(...)):
    payload = verificar_token(token)
    conn, cursor = get_db()

    cursor.execute("SELECT departamento FROM funcionarios WHERE id = ?", (funcionario_id,))
    funcionario_atual = cursor.fetchone()
    if not funcionario_atual:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Funcionário não encontrado")

    if payload["perfil"] == "super":
        cursor.execute("DELETE FROM funcionarios WHERE id = ?", (funcionario_id,))
    elif payload["perfil"] == "gestor" and funcionario_atual[0] == payload["perfil"]:
        cursor.execute("DELETE FROM funcionarios WHERE id = ?", (funcionario_id,))
    else:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Permissão insuficiente")

    conn.commit()
    conn.close()
    return {"message": "Funcionário deletado com sucesso!"}

# Instalar as dependências necessárias
!pip install uvicorn
!pip install pyngrok

# Adicionar o authtoken do Ngrok
!ngrok config add-authtoken 2pOZPxewEyjvoL3kHWSWg8ZjpgQ_26sM6BitGAeeGi2GAmQE

# Importando as bibliotecas necessárias
from fastapi import FastAPI
from pyngrok import ngrok

# Criando a aplicação FastAPI
app = FastAPI()

@app.get("/")
def read_root():
    return {"message": "Hello, World!"}

# Abrindo o túnel Ngrok na porta 8000 (porta padrão do FastAPI)
public_url = ngrok.connect(8000)
print('FastAPI app disponível em:', public_url)

# Rodando o servidor FastAPI com uvicorn
!uvicorn main:app --host 0.0.0.0 --port 8000 --reload